<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Il Gioco del Moka â€” CittÃ </title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
html,body { width:100%; height:100%; background:#0a0f1a; overflow:hidden; font-family:'Georgia',serif; touch-action:none; }
#ui { position:fixed; inset:0; pointer-events:none; z-index:10; }
#header { position:absolute; top:0; left:0; right:0; padding:14px 18px; display:flex; justify-content:space-between; align-items:center; background:linear-gradient(to bottom,rgba(0,0,0,0.85),transparent); }
#logo { font-size:1.1rem; color:#D4AF37; letter-spacing:2px; text-shadow:0 2px 10px rgba(0,0,0,0.9); }
#punti-box { background:rgba(0,0,0,0.65); border:1px solid #D4AF37; border-radius:20px; padding:5px 14px; color:#D4AF37; font-size:0.8rem; text-align:center; backdrop-filter:blur(10px); }
#punti-box strong { font-size:1.1rem; display:block; line-height:1.2; }
#avatar-card { position:absolute; top:66px; left:14px; background:rgba(0,0,0,0.75); border:1px solid rgba(212,175,55,0.4); border-radius:14px; padding:9px 13px; backdrop-filter:blur(12px); display:flex; align-items:center; gap:10px; }
#avatar-emoji { font-size:1.8rem; }
#avatar-nome { color:#fff; font-size:0.9rem; font-weight:bold; }
#avatar-pos { color:#D4AF37; font-size:0.72rem; margin-top:2px; }
#btn-dado { position:absolute; bottom:105px; left:50%; transform:translateX(-50%); pointer-events:all; cursor:pointer; display:flex; flex-direction:column; align-items:center; gap:5px; }
#dado-visual { width:72px; height:72px; background:linear-gradient(135deg,#ffffff,#d8d8d8); border-radius:14px; display:flex; align-items:center; justify-content:center; font-size:2.6rem; box-shadow:0 0 0 3px #D4AF37,0 8px 28px rgba(212,175,55,0.55); animation:dado-idle 2s ease-in-out infinite; user-select:none; }
@keyframes dado-idle { 0%,100%{transform:rotate(-3deg) scale(1);} 50%{transform:rotate(3deg) scale(1.07);} }
#dado-visual.rotola { animation:dado-rotola 0.85s cubic-bezier(0.36,0.07,0.19,0.97) forwards; }
@keyframes dado-rotola { 0%{transform:rotate(0) scale(1);} 25%{transform:rotate(-30deg) scale(1.3) translateY(-20px);} 55%{transform:rotate(25deg) scale(1.25) translateY(-22px);} 80%{transform:rotate(-8deg) scale(1.05) translateY(-4px);} 100%{transform:rotate(0) scale(1);} }
#dado-label { color:#D4AF37; font-size:0.78rem; font-weight:bold; letter-spacing:2px; text-shadow:0 2px 8px rgba(0,0,0,0.9); animation:pulse-label 1.5s ease-in-out infinite; }
@keyframes pulse-label { 0%,100%{opacity:1;} 50%{opacity:0.4;} }
#mondo-bar { position:absolute; bottom:46px; left:14px; right:14px; background:rgba(0,0,0,0.7); border-radius:12px; padding:9px 13px; backdrop-filter:blur(12px); border:1px solid rgba(255,255,255,0.07); }
#mondo-nome { color:#D4AF37; font-size:0.78rem; font-weight:bold; letter-spacing:1px; margin-bottom:5px; }
#mondo-pw { height:5px; background:rgba(255,255,255,0.1); border-radius:3px; overflow:hidden; }
#mondo-pf { height:100%; background:linear-gradient(90deg,#C8961E,#D4AF37); border-radius:3px; transition:width 1.5s ease; width:0%; }
#risultato-box { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%) scale(0); background:rgba(4,2,1,0.96); border:2px solid #D4AF37; border-radius:20px; padding:22px 26px; text-align:center; backdrop-filter:blur(22px); pointer-events:all; transition:transform 0.4s cubic-bezier(0.34,1.56,0.64,1); min-width:240px; max-width:85vw; }
#risultato-box.visibile { transform:translate(-50%,-50%) scale(1); }
#ris-dado { font-size:3rem; margin-bottom:4px; }
#ris-titolo { color:#D4AF37; font-size:1.15rem; font-weight:bold; margin-bottom:5px; }
#ris-desc { color:rgba(255,255,255,0.65); font-size:0.86rem; margin-bottom:14px; }
#ris-casella { color:rgba(255,255,255,0.4); font-size:0.75rem; margin-bottom:14px; }
#ris-btn { background:linear-gradient(135deg,#C8961E,#D4AF37); color:#000; border:none; border-radius:25px; padding:11px 26px; font-size:0.92rem; font-weight:bold; cursor:pointer; }
#premio-overlay { position:absolute; inset:0; background:rgba(0,0,0,0.92); display:flex; align-items:center; justify-content:center; z-index:20; opacity:0; pointer-events:none; transition:opacity 0.5s; }
#premio-overlay.visibile { opacity:1; pointer-events:all; }
#premio-inner { text-align:center; padding:28px 32px; }
#premio-emoji-big { font-size:64px; animation:pb 0.7s ease infinite alternate; display:block; margin-bottom:10px; }
@keyframes pb { from{transform:scale(1) rotate(-5deg);} to{transform:scale(1.12) rotate(5deg);} }
#premio-titolo { font-size:1.7rem; color:#D4AF37; margin-bottom:6px; text-shadow:0 0 30px rgba(212,175,55,0.7); }
#premio-nome { color:#fff; font-size:1.05rem; margin-bottom:14px; }
#premio-codice { background:rgba(212,175,55,0.1); border:2px solid #D4AF37; border-radius:12px; padding:11px 20px; font-size:1.6rem; font-family:monospace; color:#D4AF37; letter-spacing:5px; margin-bottom:20px; display:inline-block; }
#premio-chiudi { background:linear-gradient(135deg,#C8961E,#D4AF37); color:#000; border:none; border-radius:25px; padding:13px 32px; font-size:0.97rem; font-weight:bold; cursor:pointer; }
#toast { position:absolute; top:155px; left:50%; transform:translateX(-50%) translateY(-10px); background:rgba(212,175,55,0.92); color:#000; border-radius:20px; padding:7px 18px; font-weight:bold; font-size:0.88rem; opacity:0; transition:all 0.28s; white-space:nowrap; pointer-events:none; }
#toast.show { opacity:1; transform:translateX(-50%) translateY(0); }
#loading { position:fixed; inset:0; background:#0a0f1a; display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:100; transition:opacity 0.8s; }
#loading .cup { font-size:56px; animation:float-cup 1.2s ease-in-out infinite; margin-bottom:16px; }
@keyframes float-cup { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-12px);} }
#loading p { color:#D4AF37; letter-spacing:3px; font-size:0.9rem; margin-bottom:14px; }
#loading-bar { width:200px; height:4px; background:rgba(255,255,255,0.1); border-radius:2px; overflow:hidden; }
#loading-fill { height:100%; background:linear-gradient(90deg,#C8961E,#D4AF37); width:0%; transition:width 0.2s ease; border-radius:2px; }
#loading-status { color:rgba(255,255,255,0.4); font-size:0.72rem; margin-top:8px; letter-spacing:1px; }
.coriandolo { position:absolute; pointer-events:none; animation:cori-fall linear forwards; }
@keyframes cori-fall { 0%{opacity:1;transform:translateY(0) rotate(0);} 100%{opacity:0;transform:translateY(100vh) rotate(720deg);} }
#minimap { position:absolute; top:66px; right:14px; width:90px; height:90px; background:rgba(0,0,0,0.7); border:1px solid rgba(212,175,55,0.3); border-radius:10px; backdrop-filter:blur(8px); overflow:hidden; }
#minimap canvas { width:100%; height:100%; }
</style>
</head>
<body>

<div id="loading">
  <div class="cup">ğŸš—</div>
  <p>COSTRUZIONE CITTÃ€...</p>
  <div id="loading-bar"><div id="loading-fill"></div></div>
  <div id="loading-status">Caricamento modelli...</div>
</div>

<div id="ui">
  <div id="header">
    <div id="logo">â˜• IL GIOCO DEL MOKA</div>
    <div id="punti-box"><strong>45</strong>PUNTI</div>
  </div>
  <div id="avatar-card">
    <div id="avatar-emoji">ğŸš—</div>
    <div><div id="avatar-nome">Anselmo</div><div id="avatar-pos">Casella 1 Â· Quartiere A</div></div>
  </div>
  <div id="minimap"><canvas id="minimap-canvas"></canvas></div>
  <div id="toast"></div>
  <div id="btn-dado">
    <div id="dado-visual">ğŸ²</div>
    <div id="dado-label">â¬¡ LANCIA â¬¡</div>
  </div>
  <div id="risultato-box">
    <div id="ris-dado">ğŸ²</div>
    <div id="ris-titolo"></div>
    <div id="ris-desc"></div>
    <div id="ris-casella"></div>
    <button id="ris-btn" onclick="chiudiRisultato()">Continua â†’</button>
  </div>
  <div id="premio-overlay">
    <div id="premio-inner">
      <span id="premio-emoji-big">ğŸ</span>
      <div id="premio-titolo">HAI VINTO!</div>
      <div id="premio-nome"></div>
      <div id="premio-codice"></div>
      <button id="premio-chiudi" onclick="chiudiPremio()">ğŸ‰ Fantastico!</button>
    </div>
  </div>
  <div id="mondo-bar">
    <div id="mondo-nome">ğŸ˜ï¸ QUARTIERE A â€” IL VILLAGGIO</div>
    <div id="mondo-pw"><div id="mondo-pf"></div></div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLTF LOADER MINIMALE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class GLTFLoader {
  load(url, onLoad, onProgress, onError) {
    fetch(url).then(r => r.arrayBuffer()).then(buf => {
      try { this.parse(buf, onLoad); }
      catch(e) { onError&&onError(e); }
    }).catch(e => onError&&onError(e));
  }
  parse(buffer, onLoad) {
    const view = new DataView(buffer);
    if (view.getUint32(0,true) !== 0x46546C67) throw new Error('Not GLB');
    const jsonLen = view.getUint32(12,true);
    const gltf = JSON.parse(new TextDecoder().decode(new Uint8Array(buffer,20,jsonLen)));
    const binStart = 20+jsonLen+8;
    const bin = buffer.slice(binStart);
    onLoad({ scene: this._build(gltf, bin) });
  }
  _build(gltf, bin) {
    const root = new THREE.Group();
    const bvs = gltf.bufferViews||[];
    const accs = gltf.accessors||[];
    const getArr = i => {
      const a=accs[i], bv=bvs[a.bufferView];
      const off=(bv.byteOffset||0)+(a.byteOffset||0);
      const n={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT4:16}[a.type]||1;
      const T={5121:Uint8Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array}[a.componentType]||Float32Array;
      return new T(bin,off,a.count*n);
    };
    const tl = new THREE.TextureLoader();
    const colormap = tl.load('Textures/colormap.png');
    colormap.flipY = false;
    const mats = (gltf.materials||[]).map(m => {
      const mat = new THREE.MeshLambertMaterial({color:0xffffff, map:colormap});
      return mat;
    });
    const buildNode = nd => {
      const g = new THREE.Group();
      if (nd.translation) g.position.set(...nd.translation);
      if (nd.rotation)    g.quaternion.set(...nd.rotation);
      if (nd.scale)       g.scale.set(...nd.scale);
      if (nd.mesh != null) {
        for (const prim of gltf.meshes[nd.mesh].primitives||[]) {
          const geo = new THREE.BufferGeometry();
          const A = prim.attributes;
          if (A.POSITION  != null) geo.setAttribute('position',new THREE.BufferAttribute(getArr(A.POSITION),3));
          if (A.NORMAL    != null) geo.setAttribute('normal',  new THREE.BufferAttribute(getArr(A.NORMAL),3));
          if (A.TEXCOORD_0!= null) geo.setAttribute('uv',      new THREE.BufferAttribute(getArr(A.TEXCOORD_0),2));
          if (prim.indices!= null) geo.setIndex(new THREE.BufferAttribute(getArr(prim.indices),1));
          geo.computeVertexNormals();
          const mat = prim.material!=null ? mats[prim.material] : new THREE.MeshLambertMaterial({color:0xaaa,map:colormap});
          const mesh = new THREE.Mesh(geo,mat);
          mesh.castShadow = mesh.receiveShadow = true;
          g.add(mesh);
        }
      }
      for (const ci of nd.children||[]) g.add(buildNode(gltf.nodes[ci]));
      return g;
    };
    const sc = gltf.scenes?.[gltf.scene??0];
    for (const ni of sc?.nodes||[]) root.add(buildNode(gltf.nodes[ni]));
    return root;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDERER & SCENA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setClearColor(0x87CEEB); // cielo azzurro
document.body.insertBefore(renderer.domElement, document.getElementById('ui'));

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x87CEEB, 40, 90);
scene.background = new THREE.Color(0x87CEEB);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0, 22, 22);
camera.lookAt(0, 0, 0);

// LUCI
scene.add(new THREE.AmbientLight(0xfff0dd, 0.7));
const sun = new THREE.DirectionalLight(0xfffae0, 1.2);
sun.position.set(15, 30, 20);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
sun.shadow.camera.left=-50; sun.shadow.camera.right=50;
sun.shadow.camera.top=50;   sun.shadow.camera.bottom=-50;
sun.shadow.camera.far=120;
scene.add(sun);
scene.add(new THREE.DirectionalLight(0x8899ff, 0.2).position.set(-10,8,-8) && new THREE.DirectionalLight(0x8899ff,0.2));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYOUT CITTÃ€ â€” percorso a serpentina 120 caselle
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CELL = 4.0; // dimensione casella
const COLS = 10;  // larghezza griglia

// Genera percorso a serpentina: 120 caselle
// Zig-zag: riga 0 â†’ sinistra, riga 1 â†’ destra, ecc.
function generaPercorso() {
  const path = [];
  const rows = 12; // 12 righe Ã— 10 colonne = 120
  for (let r = 0; r < rows; r++) {
    if (r % 2 === 0) {
      for (let c = 0; c < COLS; c++) path.push({r, c});
    } else {
      for (let c = COLS-1; c >= 0; c--) path.push({r, c});
    }
  }
  return path;
}
const PERCORSO = generaPercorso();
const N = PERCORSO.length; // 120

function cellToWorld(r, c) {
  const offX = -(COLS-1)*CELL/2;
  const offZ = -(12-1)*CELL/2;
  return { x: offX + c*CELL, z: offZ + r*CELL };
}

// Calcola direzione di avanzamento per ogni casella
function calcolaDirezioni() {
  const dirs = [];
  for (let i = 0; i < N; i++) {
    const curr = PERCORSO[i];
    const next = PERCORSO[Math.min(i+1, N-1)];
    const dc = next.c - curr.c;
    const dr = next.r - curr.r;
    let angle = 0;
    if (dc > 0) angle = Math.PI/2;
    else if (dc < 0) angle = -Math.PI/2;
    else if (dr > 0) angle = Math.PI;
    else if (dr < 0) angle = 0;
    dirs.push(angle);
  }
  return dirs;
}
const DIREZIONI = calcolaDirezioni();

// TIPI CASELLE
const TIPI_CASELLA = [];
for (let i = 0; i < 120; i++) {
  let t = 'normale';
  if (i === 0) t = 'partenza';
  else if (i === 119) t = 'moka'; // traguardo = Il Ristorante Moka
  else if ([9,19,29,39,49,59,69,79,89,99,109].includes(i)) t = 'premio';
  else if ([4,14,24,34,44,54,64,74,84,94,104,114].includes(i)) t = 'bonus';
  else if ([7,17,27,37,47,57,67,77,87,97,107,117].includes(i)) t = 'malus';
  else if ([12,32,52,72,92,112].includes(i)) t = 'sorpresa';
  else if ([39,79].includes(i)) t = 'checkpoint'; // fine quartiere
  TIPI_CASELLA.push(t);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PIANO STRADALE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Piano base (erba/asfalto)
const groundGeo = new THREE.PlaneGeometry(COLS*CELL+20, 12*CELL+20);

// Texture asfalto procedurale
const asfCanvas = document.createElement('canvas');
asfCanvas.width = asfCanvas.height = 512;
const asfCtx = asfCanvas.getContext('2d');
asfCtx.fillStyle = '#2a2a35';
asfCtx.fillRect(0,0,512,512);
// rumore asfalto
for (let i=0;i<3000;i++) {
  const v = 35+Math.random()*15;
  asfCtx.fillStyle = `rgb(${v},${v},${v+5})`;
  asfCtx.fillRect(Math.random()*512, Math.random()*512, 1+Math.random()*2, 1+Math.random()*2);
}
const asfTex = new THREE.CanvasTexture(asfCanvas);
asfTex.wrapS = asfTex.wrapT = THREE.RepeatWrapping;
asfTex.repeat.set(COLS*2, 12*2);

const ground = new THREE.Mesh(groundGeo, new THREE.MeshLambertMaterial({map:asfTex}));
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// Erba sui bordi
const grassBorderMat = new THREE.MeshLambertMaterial({color:0x3a8a3a});
[
  [0, -(12*CELL/2+3), COLS*CELL+20, 6],
  [0,  (12*CELL/2+3), COLS*CELL+20, 6],
  [-(COLS*CELL/2+3), 0, 6, 12*CELL+20],
  [ (COLS*CELL/2+3), 0, 6, 12*CELL+20],
].forEach(([x,z,w,d]) => {
  const m = new THREE.Mesh(new THREE.PlaneGeometry(w,d), grassBorderMat);
  m.rotation.x = -Math.PI/2; m.position.set(x,0.01,z); m.receiveShadow=true; scene.add(m);
});

// Strisce stradali tra caselle
const strisciaMat = new THREE.MeshLambertMaterial({color:0xf0f0f0});
for (let i=0; i<N-1; i++) {
  const curr = PERCORSO[i], next = PERCORSO[i+1];
  const wc = cellToWorld(curr.r, curr.c);
  const wn = cellToWorld(next.r, next.c);
  // Striscia tratteggiata al centro
  const mx = (wc.x+wn.x)/2, mz = (wc.z+wn.z)/2;
  const s = new THREE.Mesh(new THREE.PlaneGeometry(0.12, CELL*0.35), strisciaMat);
  s.rotation.x = -Math.PI/2;
  const dc=next.c-curr.c, dr=next.r-curr.r;
  if (dc!==0) s.rotation.z = Math.PI/2;
  s.position.set(mx, 0.05, mz);
  scene.add(s);
}

// Marcatori caselle speciali
PERCORSO.forEach((p, i) => {
  const {x,z} = cellToWorld(p.r, p.c);
  const tipo = TIPI_CASELLA[i];
  let color = null;
  if (tipo==='premio')     color = 0xFFD700;
  if (tipo==='bonus')      color = 0x00cc44;
  if (tipo==='malus')      color = 0xcc2200;
  if (tipo==='sorpresa')   color = 0x8800cc;
  if (tipo==='moka')       color = 0xD4AF37;
  if (tipo==='partenza')   color = 0x00aaff;
  if (tipo==='checkpoint') color = 0xff8800;
  if (color) {
    const dot = new THREE.Mesh(
      new THREE.CylinderGeometry(0.5,0.5,0.06,8),
      new THREE.MeshLambertMaterial({color, transparent:true, opacity:0.85})
    );
    dot.position.set(x, 0.06, z);
    scene.add(dot);
  }
  // Numero casella
  const nc = document.createElement('canvas'); nc.width=nc.height=64;
  const nx=nc.getContext('2d');
  nx.fillStyle=color?`rgba(0,0,0,0.6)`:'rgba(0,0,0,0.35)';
  nx.beginPath(); nx.arc(32,32,24,0,Math.PI*2); nx.fill();
  nx.fillStyle=color?'#fff':'rgba(255,255,255,0.6)';
  nx.font=`bold ${i>=99?16:18}px Arial`; nx.textAlign='center'; nx.textBaseline='middle';
  nx.fillText(i+1,32,32);
  const nm=new THREE.Mesh(new THREE.PlaneGeometry(0.8,0.8),new THREE.MeshBasicMaterial({map:new THREE.CanvasTexture(nc),transparent:true,depthWrite:false}));
  nm.rotation.x=-Math.PI/2; nm.position.set(x,0.08,z); scene.add(nm);
});

// Cielo â€” sfumatura
const skyGeo = new THREE.SphereGeometry(90,16,8);
const skyMat = new THREE.ShaderMaterial({
  side: THREE.BackSide,
  uniforms: { topColor:{value:new THREE.Color(0x4488cc)}, bottomColor:{value:new THREE.Color(0x87CEEB)} },
  vertexShader: `varying float h; void main(){h=position.y;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
  fragmentShader: `varying float h; uniform vec3 topColor,bottomColor; void main(){float t=clamp(h/60.0,0.0,1.0);gl_FragColor=vec4(mix(bottomColor,topColor,t),1.0);}`
});
scene.add(new THREE.Mesh(skyGeo,skyMat));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CARICAMENTO MODELLI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const loader = new GLTFLoader();
const MODELLI = {
  edifici: [
    'building-a','building-b','building-c','building-d','building-e',
    'building-f','building-g','building-h','building-i','building-j',
    'building-k','building-l','building-m','building-n',
    'building-skyscraper-a','building-skyscraper-b','building-skyscraper-c',
    'low-detail-building-a','low-detail-building-b','low-detail-building-c',
    'low-detail-building-d','low-detail-building-e','low-detail-building-f',
    'low-detail-building-wide-a','low-detail-building-wide-b'
  ],
  macchine: ['sedan','taxi','race','sedan-sports','suv','police','hatchback-sports'],
  dettagli: ['detail-parasol-a','detail-parasol-b','detail-awning']
};

const loaded = { edifici:{}, macchine:{}, dettagli:{} };
let totaleModelli = Object.values(MODELLI).reduce((s,a)=>s+a.length,0);
let loadedCount = 0;

function aggiornaLoading(nome) {
  loadedCount++;
  const pct = Math.round(loadedCount/totaleModelli*100);
  document.getElementById('loading-fill').style.width = pct+'%';
  document.getElementById('loading-status').textContent = nome;
  if (loadedCount >= totaleModelli) setTimeout(costruisciCitta, 300);
}

function caricaGruppo(gruppo, dict) {
  MODELLI[gruppo].forEach(nome => {
    loader.load(nome+'.glb', gltf => {
      dict[nome] = gltf.scene;
      aggiornaLoading(nome);
    }, null, () => {
      dict[nome] = null;
      aggiornaLoading(nome+'(fallback)');
    });
  });
}
caricaGruppo('edifici', loaded.edifici);
caricaGruppo('macchine', loaded.macchine);
caricaGruppo('dettagli', loaded.dettagli);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COSTRUZIONE CITTÃ€
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function costruisciCitta() {
  const percSet = new Set(PERCORSO.map(p=>`${p.r},${p.c}`));
  const edificiValidi = Object.values(loaded.edifici).filter(m=>m);
  const dettagliValidi = Object.values(loaded.dettagli).filter(m=>m);

  if (edificiValidi.length === 0) {
    // Fallback: cubi colorati
    costruisciCittaFallback(percSet);
  } else {
    costruisciCittaConModelli(percSet, edificiValidi, dettagliValidi);
  }

  posizionaMacchineDecorativeEstatiche();
  nascondiLoading();
}

function costruisciCittaConModelli(percSet, edificiValidi, dettagliValidi) {
  let idx = 0;
  for (let r = 0; r < 12; r++) {
    for (let c = 0; c < COLS; c++) {
      if (percSet.has(`${r},${c}`)) continue; // strada
      const {x,z} = cellToWorld(r,c);
      const model = edificiValidi[idx % edificiValidi.length].clone();
      // Scala: gli edifici Kenney sono ~2-3 unitÃ  â€” scala a CELL
      const s = 0.9 + Math.random()*0.4;
      model.scale.set(s,s,s);
      model.position.set(x, 0, z);
      model.rotation.y = Math.floor(Math.random()*4)*Math.PI/2;
      model.traverse(m=>{ if(m.isMesh){m.castShadow=true; m.receiveShadow=true;} });
      scene.add(model);
      // Dettaglio occasionale (tenda, parasole)
      if (dettagliValidi.length && Math.random()>0.7) {
        const d = dettagliValidi[Math.floor(Math.random()*dettagliValidi.length)].clone();
        d.scale.set(0.8,0.8,0.8);
        d.position.set(x+(Math.random()-0.5)*1.2, 0, z+(Math.random()-0.5)*1.2);
        d.rotation.y = Math.random()*Math.PI*2;
        scene.add(d);
      }
      idx++;
    }
  }
}

function costruisciCittaFallback(percSet) {
  const colors = [0x8B4513,0xA0522D,0x6B8E23,0x4682B4,0x808080,0xB8860B];
  let ci=0;
  for (let r=0;r<12;r++) for (let c=0;c<COLS;c++) {
    if (percSet.has(`${r},${c}`)) continue;
    const {x,z}=cellToWorld(r,c);
    const h=1.5+Math.random()*3;
    const m=new THREE.Mesh(new THREE.BoxGeometry(CELL*0.75,h,CELL*0.75),new THREE.MeshLambertMaterial({color:colors[ci++%colors.length]}));
    m.position.set(x,h/2,z); m.castShadow=true; scene.add(m);
  }
}

function posizionaMacchineDecorativeEstatiche() {
  const macchineNomi = ['sedan','suv','police','sedan-sports'];
  macchineNomi.forEach((nome,i) => {
    const model = loaded.macchine[nome];
    if (!model) return;
    // Posiziona macchine parcheggiate lungo le strade
    [3,7,15,22,30].forEach((idx,j) => {
      if (idx+i >= N) return;
      const p = PERCORSO[(idx+i*5)%N];
      const {x,z} = cellToWorld(p.r, p.c);
      const clone = model.clone();
      clone.scale.set(0.9,0.9,0.9);
      clone.position.set(x+1.2*(j%2===0?1:-1), 0, z+0.5);
      clone.rotation.y = DIREZIONI[(idx+i*5)%N];
      clone.traverse(m=>{ if(m.isMesh){m.castShadow=true; m.receiveShadow=true;} });
      scene.add(clone);
    });
  });
}

function nascondiLoading() {
  const ld = document.getElementById('loading');
  ld.style.opacity = '0';
  setTimeout(()=>ld.style.display='none', 800);
  iniziaGioco();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MACCHINA GIOCATORE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let playerCar = null;
let playerCarGroup = new THREE.Group();
scene.add(playerCarGroup);

function iniziaGioco() {
  // Usa taxi come macchina giocatore (colorata di default)
  const nomiAuto = ['taxi','race','kart-oobi','kart-oopi','kart-oozi'];
  for (const nome of nomiAuto) {
    if (loaded.macchine[nome]) { playerCar = loaded.macchine[nome].clone(); break; }
  }
  if (!playerCar) {
    // Fallback: box
    playerCar = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.5,1.4), new THREE.MeshLambertMaterial({color:0xFFD700}));
  }
  playerCar.scale.set(1.05,1.05,1.05);
  playerCar.traverse(m=>{ if(m.isMesh){m.castShadow=true;} });
  // Alone dorato sotto
  const glowRing = new THREE.Mesh(
    new THREE.RingGeometry(0.8,1.1,16),
    new THREE.MeshBasicMaterial({color:0xD4AF37,transparent:true,opacity:0.5,side:THREE.DoubleSide,depthWrite:false})
  );
  glowRing.rotation.x=-Math.PI/2; glowRing.position.y=0.05;
  playerCarGroup.add(glowRing);
  playerCarGroup.add(playerCar);
  posizionaPlayerSuCasella(0, true);
  aggiornaMinimappa();
}

function posizionaPlayerSuCasella(idx, immediato=false) {
  const p = PERCORSO[idx];
  const {x,z} = cellToWorld(p.r, p.c);
  if (immediato) {
    playerCarGroup.position.set(x, 0, z);
    playerCarGroup.rotation.y = DIREZIONI[idx];
  } else {
    playerCarGroup.position.set(x, 0, z);
    playerCarGroup.rotation.y = DIREZIONI[idx];
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CAMERA CINEMATOGRAFICA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let camMode = 'overview'; // 'overview' | 'follow'
let camTargetPos = new THREE.Vector3(0,22,22);
let camTargetLook = new THREE.Vector3(0,0,0);
let camCurrentLook = new THREE.Vector3(0,0,0);

// Timeout per tornare all'overview dopo un lancio
let overviewTimer = null;

function setCamFollow(idx) {
  camMode = 'follow';
  const p = PERCORSO[idx];
  const {x,z} = cellToWorld(p.r, p.c);
  const dir = DIREZIONI[idx];
  // Camera dietro e sopra la macchina â€” quasi a livello strada
  camTargetPos.set(
    x - Math.sin(dir)*7,
    6,
    z - Math.cos(dir)*7
  );
  camTargetLook.set(x, 1, z);
}

function setCamOverview() {
  camMode = 'overview';
  camTargetPos.set(0, 28, 28);
  camTargetLook.set(0, 0, 0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MINIMAP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function aggiornaMinimappa() {
  const mc = document.getElementById('minimap-canvas');
  mc.width = mc.height = 180;
  const mx = mc.getContext('2d');
  mx.fillStyle='#0a0f1a'; mx.fillRect(0,0,180,180);
  const pw=180/COLS, ph=180/12;
  // Disegna percorso
  PERCORSO.forEach((p,i)=>{
    const tipo = TIPI_CASELLA[i];
    if (tipo==='premio')   mx.fillStyle='#FFD700';
    else if(tipo==='bonus')  mx.fillStyle='#00cc44';
    else if(tipo==='malus')  mx.fillStyle='#cc2200';
    else if(tipo==='moka')   mx.fillStyle='#D4AF37';
    else mx.fillStyle='rgba(255,255,255,0.25)';
    mx.fillRect(p.c*pw+1, p.r*ph+1, pw-2, ph-2);
  });
  // Player
  if (posCorrente < N) {
    const p = PERCORSO[posCorrente];
    mx.fillStyle='#fff';
    mx.beginPath();
    mx.arc(p.c*pw+pw/2, p.r*ph+ph/2, 4, 0, Math.PI*2);
    mx.fill();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOGICA GIOCO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let posCorrente = 0;
let staAnimando = false;

const PREMI_LIST = ['â˜• CaffÃ¨ Espresso','ğŸ‚ Dessert del Giorno','ğŸ· Calice di Vino','ğŸ Sconto 10%','ğŸ¾ Bottiglia di Vino','ğŸ• Pizza omaggio','ğŸ¥— Antipasto misto'];

const MONDI_DESC = [
  {da:0,  a:39,  nome:'ğŸ˜ï¸ QUARTIERE A â€” IL VILLAGGIO',  emoji:'ğŸ˜ï¸'},
  {da:40, a:79,  nome:'ğŸ· QUARTIERE B â€” LA CANTINA',     emoji:'ğŸ·'},
  {da:80, a:119, nome:'ğŸ‘¨â€ğŸ³ QUARTIERE C â€” CUCINA DELLO CHEF', emoji:'â­'},
];

document.getElementById('btn-dado').addEventListener('click', ()=>{ if(!staAnimando && playerCar) lanciaDado(); });

function lanciaDado() {
  staAnimando = true;
  const el = document.getElementById('dado-visual');
  el.classList.remove('rotola'); void el.offsetWidth; el.classList.add('rotola');
  const r = Math.ceil(Math.random()*6);
  setTimeout(()=>{
    el.textContent = ['âš€','âš','âš‚','âšƒ','âš„','âš…'][r-1];
    animaMovimento(r);
  }, 880);
}

function animaMovimento(passi) {
  let step = 0;
  camMode = 'follow';
  function next() {
    if (step >= passi) {
      setTimeout(()=>{
        setCamFollow(posCorrente);
        setTimeout(()=>mostraRisultato(passi), 1000);
      }, 200);
      return;
    }
    step++;
    posCorrente = Math.min(posCorrente+1, N-1);
    posizionaPlayerSuCasella(posCorrente);
    setCamFollow(posCorrente);
    aggiornaMinimappa();
    aggiornaUI();
    toast(`${step}/${passi}`);
    setTimeout(next, 340 - step*20);
  }
  next();
}

function mostraRisultato(passi) {
  const tipo = TIPI_CASELLA[posCorrente];
  const box = document.getElementById('risultato-box');
  document.getElementById('ris-dado').textContent = ['âš€','âš','âš‚','âšƒ','âš„','âš…'][passi-1];
  const configs = {
    normale:     {titolo: 'ğŸš— Avanti!',            desc: 'Continui il tuo percorso per la cittÃ .'},
    premio:      {titolo: 'ğŸ Premio!',             desc: 'Sei arrivato davanti a un locale speciale!'},
    bonus:       {titolo: 'âš¡ Semaforo Verde!',      desc: 'Via libera â€” avanza di 2 caselle extra!'},
    malus:       {titolo: 'ğŸš§ Lavori in Corso!',    desc: 'Rallenti e torni indietro di 2 caselle.'},
    sorpresa:    {titolo: 'â“ Strada Misteriosa!',   desc: 'Effetto sorpresa â€” non sai mai cosa aspettarti!'},
    partenza:    {titolo: 'ğŸ Si Parte!',            desc: 'Sei alla partenza. Buona fortuna!'},
    checkpoint:  {titolo: 'ğŸ† Quartiere Superato!', desc: 'Ottimo! Sei entrato nel prossimo quartiere.'},
    moka:        {titolo: 'â˜• Ristorante Moka!',    desc: 'Ce l\'hai fatta! Sei arrivato al Ristorante Moka!'},
  };
  const cfg = configs[tipo] || configs.normale;
  document.getElementById('ris-titolo').textContent = cfg.titolo;
  document.getElementById('ris-desc').textContent = cfg.desc;
  document.getElementById('ris-casella').textContent = `Casella ${posCorrente+1} di 120`;
  box.classList.add('visibile');
  if (tipo==='premio'||tipo==='moka'||tipo==='checkpoint') {
    setTimeout(()=>{ box.classList.remove('visibile'); mostraPremio(tipo); }, 1400);
  }
}

function chiudiRisultato() {
  document.getElementById('risultato-box').classList.remove('visibile');
  setCamOverview();
  staAnimando = false;
}
window.chiudiRisultato = chiudiRisultato;

function mostraPremio(tipo) {
  const nome = tipo==='moka'
    ? 'ğŸ½ï¸ Cena per 2 al Ristorante Moka!'
    : tipo==='checkpoint'
    ? 'ğŸ¥‚ Calice di benvenuto nel nuovo quartiere!'
    : PREMI_LIST[Math.floor(Math.random()*PREMI_LIST.length)];
  const code = 'MK-'+Math.random().toString(36).substr(2,4).toUpperCase();
  document.getElementById('premio-emoji-big').textContent = tipo==='moka'?'â˜•':'ğŸ';
  document.getElementById('premio-titolo').textContent = tipo==='moka'?'TRAGUARDO!':'HAI VINTO!';
  document.getElementById('premio-nome').textContent = nome;
  document.getElementById('premio-codice').textContent = code;
  document.getElementById('premio-overlay').classList.add('visibile');
  coriandoli(tipo==='moka'?120:70);
}
function chiudiPremio() {
  document.getElementById('premio-overlay').classList.remove('visibile');
  setCamOverview();
  staAnimando = false;
}
window.chiudiPremio = chiudiPremio;

function aggiornaUI() {
  const mondo = MONDI_DESC.find(m=>posCorrente>=m.da&&posCorrente<=m.a)||MONDI_DESC[0];
  document.getElementById('avatar-pos').textContent = `Casella ${posCorrente+1} Â· ${mondo.emoji}`;
  document.getElementById('mondo-nome').textContent = mondo.nome;
  const pct = ((posCorrente-mondo.da)/(mondo.a-mondo.da)*100).toFixed(0);
  document.getElementById('mondo-pf').style.width = pct+'%';
}

let toastT;
function toast(msg) {
  const el=document.getElementById('toast');el.textContent=msg;el.classList.add('show');
  clearTimeout(toastT);toastT=setTimeout(()=>el.classList.remove('show'),600);
}

function coriandoli(n) {
  const ui=document.getElementById('ui');
  const col=['#D4AF37','#C8961E','#52B788','#E74C3C','#3498DB','#9B59B6','#fff','#ff8800'];
  for(let i=0;i<n;i++){
    const el=document.createElement('div');el.className='coriandolo';
    const dur=1.8+Math.random()*2;
    el.style.cssText=`left:${Math.random()*100}vw;top:-20px;width:${5+Math.random()*9}px;height:${5+Math.random()*9}px;background:${col[i%col.length]};border-radius:${Math.random()>.5?'50%':'2px'};animation-duration:${dur}s;animation-delay:${Math.random()*.4}s;`;
    ui.appendChild(el);setTimeout(()=>el.remove(),(dur+0.5)*1000);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOUCH / MOUSE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let drag={active:false,x:0,y:0};
let manualCam={angle:0,h:22,dist:28};
let manualMode=false;

renderer.domElement.addEventListener('touchstart',e=>{
  if(e.touches.length===1){drag={active:true,x:e.touches[0].clientX,y:e.touches[0].clientY};manualMode=true;}
},{passive:true});
renderer.domElement.addEventListener('touchmove',e=>{
  if(drag.active&&e.touches.length===1){
    manualCam.angle+=(e.touches[0].clientX-drag.x)*0.01;
    manualCam.h=Math.max(4,Math.min(40,manualCam.h-(e.touches[0].clientY-drag.y)*0.06));
    drag.x=e.touches[0].clientX;drag.y=e.touches[0].clientY;
  }
},{passive:true});
renderer.domElement.addEventListener('touchend',()=>drag.active=false);
renderer.domElement.addEventListener('mousedown',e=>{drag={active:true,x:e.clientX,y:e.clientY};manualMode=true;});
renderer.domElement.addEventListener('mousemove',e=>{
  if(!drag.active)return;
  manualCam.angle+=(e.clientX-drag.x)*0.01;
  manualCam.h=Math.max(4,Math.min(40,manualCam.h-(e.clientY-drag.y)*0.06));
  drag.x=e.clientX;drag.y=e.clientY;
});
renderer.domElement.addEventListener('mouseup',()=>drag.active=false);
renderer.domElement.addEventListener('wheel',e=>{
  manualCam.dist=Math.max(8,Math.min(60,manualCam.dist+e.deltaY*0.02));manualMode=true;
},{passive:true});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let t=0,lastT=0;
const camPos=camera.position.clone();
const lookAt=new THREE.Vector3();

function animate(ts) {
  requestAnimationFrame(animate);
  const dt=Math.min((ts-lastT)/1000,0.05); lastT=ts; t+=dt;

  // Sole che gira lentamente
  sun.position.set(Math.cos(t*0.05)*40,30,Math.sin(t*0.05)*30);

  // Macchina: leggero bounce
  if (playerCarGroup) playerCarGroup.position.y = Math.sin(t*4)*0.04;

  // Camera
  if (manualMode && !staAnimando) {
    const cx=Math.sin(manualCam.angle)*manualCam.dist;
    const cz=Math.cos(manualCam.angle)*manualCam.dist;
    camPos.lerp(new THREE.Vector3(cx,manualCam.h,cz),0.06);
    lookAt.lerp(new THREE.Vector3(0,0,0),0.06);
  } else if (camMode==='follow' && staAnimando) {
    camPos.lerp(camTargetPos,0.08);
    lookAt.lerp(camTargetLook,0.08);
  } else {
    // Overview con lento orbit
    manualCam.angle+=dt*0.08;
    const cx=Math.sin(manualCam.angle)*manualCam.dist;
    const cz=Math.cos(manualCam.angle)*manualCam.dist;
    camPos.lerp(new THREE.Vector3(cx,manualCam.h,cz),0.04);
    lookAt.lerp(new THREE.Vector3(0,0,0),0.04);
  }
  camera.position.copy(camPos);
  camera.lookAt(lookAt);

  renderer.render(scene,camera);
}
requestAnimationFrame(animate);

window.addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>